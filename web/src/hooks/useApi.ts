import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'\nimport { healthApi, opportunitiesApi, syncApi, type HealthCheck, type ApiResponse, type Opportunity, type SyncLog } from '../services/api'\nimport toast from 'react-hot-toast'\n\n// Health hooks\nexport const useHealth = () => {\n  return useQuery({\n    queryKey: ['health'],\n    queryFn: async () => {\n      const response = await healthApi.getHealth()\n      return response.data\n    },\n    refetchInterval: 30000, // Refetch every 30 seconds\n  })\n}\n\nexport const useDetailedHealth = (enabled = true) => {\n  return useQuery({\n    queryKey: ['health', 'detailed'],\n    queryFn: async () => {\n      const response = await healthApi.getDetailedHealth()\n      return response.data as HealthCheck\n    },\n    refetchInterval: 60000, // Refetch every minute\n    enabled,\n  })\n}\n\n// Opportunities hooks\nexport const useOpportunities = (params?: {\n  limit?: number\n  offset?: number\n  postedFrom?: string\n  postedTo?: string\n  naicsCode?: string\n  department?: string\n  opportunityType?: string\n  searchTerm?: string\n}) => {\n  return useQuery({\n    queryKey: ['opportunities', params],\n    queryFn: async () => {\n      const response = await opportunitiesApi.getOpportunities(params)\n      return response.data as ApiResponse<Opportunity[]>\n    },\n    staleTime: 5 * 60 * 1000, // 5 minutes\n  })\n}\n\nexport const useOpportunity = (id: string) => {\n  return useQuery({\n    queryKey: ['opportunities', id],\n    queryFn: async () => {\n      const response = await opportunitiesApi.getOpportunityById(id)\n      return response.data as ApiResponse<Opportunity>\n    },\n    enabled: !!id,\n  })\n}\n\nexport const useOpportunityStatistics = () => {\n  return useQuery({\n    queryKey: ['opportunities', 'statistics'],\n    queryFn: async () => {\n      const response = await opportunitiesApi.getStatistics()\n      return response.data\n    },\n    staleTime: 10 * 60 * 1000, // 10 minutes\n  })\n}\n\n// Sync hooks\nexport const useSyncHistory = (limit = 20) => {\n  return useQuery({\n    queryKey: ['sync', 'history', limit],\n    queryFn: async () => {\n      const response = await syncApi.getSyncHistory(limit)\n      return response.data as ApiResponse<SyncLog[]>\n    },\n    refetchInterval: 30000, // Refetch every 30 seconds\n  })\n}\n\nexport const useSyncStatus = () => {\n  return useQuery({\n    queryKey: ['sync', 'status'],\n    queryFn: async () => {\n      const response = await syncApi.getSyncStatus()\n      return response.data\n    },\n    refetchInterval: 15000, // Refetch every 15 seconds\n  })\n}\n\n// Sync mutations\nexport const useManualSync = () => {\n  const queryClient = useQueryClient()\n  \n  return useMutation({\n    mutationFn: async (data: {\n      postedFrom: string\n      postedTo: string\n      ptype?: string\n      ncode?: string\n      dryRun?: boolean\n    }) => {\n      const response = await syncApi.triggerManualSync(data)\n      return response.data\n    },\n    onSuccess: () => {\n      toast.success('Manual sync started successfully')\n      // Invalidate and refetch sync-related queries\n      queryClient.invalidateQueries({ queryKey: ['sync'] })\n      queryClient.invalidateQueries({ queryKey: ['opportunities'] })\n    },\n    onError: (error: any) => {\n      toast.error(`Failed to start sync: ${error.response?.data?.message || error.message}`)\n    },\n  })\n}\n\nexport const useTestConnection = () => {\n  return useMutation({\n    mutationFn: async () => {\n      const response = await syncApi.testConnection()\n      return response.data\n    },\n    onSuccess: (data) => {\n      if (data.success) {\n        toast.success('SAM.gov API connection successful')\n      } else {\n        toast.error(`API connection failed: ${data.message}`)\n      }\n    },\n    onError: (error: any) => {\n      toast.error(`Connection test failed: ${error.response?.data?.message || error.message}`)\n    },\n  })\n}\n\nexport const useCleanupData = () => {\n  const queryClient = useQueryClient()\n  \n  return useMutation({\n    mutationFn: async () => {\n      const response = await syncApi.triggerCleanup()\n      return response.data\n    },\n    onSuccess: (data) => {\n      toast.success(`Data cleanup completed. Deleted ${data.deletedRecords} records.`)\n      queryClient.invalidateQueries({ queryKey: ['opportunities'] })\n      queryClient.invalidateQueries({ queryKey: ['sync'] })\n    },\n    onError: (error: any) => {\n      toast.error(`Cleanup failed: ${error.response?.data?.message || error.message}`)\n    },\n  })\n}\n\nexport const useClearHealthCache = () => {\n  const queryClient = useQueryClient()\n  \n  return useMutation({\n    mutationFn: async () => {\n      const response = await healthApi.clearCache()\n      return response.data\n    },\n    onSuccess: () => {\n      toast.success('Health check cache cleared')\n      queryClient.invalidateQueries({ queryKey: ['health'] })\n    },\n    onError: (error: any) => {\n      toast.error(`Failed to clear cache: ${error.response?.data?.message || error.message}`)\n    },\n  })\n}\n\n// Real-time data hook\nexport const useRealTimeUpdates = () => {\n  const queryClient = useQueryClient()\n  \n  // Simulate real-time updates by periodically invalidating queries\n  // In a real application, you might use WebSockets or Server-Sent Events\n  React.useEffect(() => {\n    const interval = setInterval(() => {\n      queryClient.invalidateQueries({ queryKey: ['health'] })\n      queryClient.invalidateQueries({ queryKey: ['sync', 'status'] })\n    }, 30000) // Every 30 seconds\n    \n    return () => clearInterval(interval)\n  }, [queryClient])\n}\n\nimport React from 'react'\n"